/**
 * roger-bot.js
 * A modern ES6 Class implementation of the RogerBot ELIZA-style chatbot.
 * * Logic derived from through 
 */

import * as Data from './roger-data.js';

export class RogerBot {
    
    /**
     * Constructor initializes the bot with configuration data.
     * @param {boolean} noRandomFlag - If true, responses cycle sequentially instead of randomly.
     */
    constructor(noRandomFlag = false) {
        // Initialization of flags
        this.noRandom = noRandomFlag;
        this.capitalizeFirstLetter = true;
        this.debug = false;
        this.memSize = 20;
        this.version = "1.1 (modernized)";

        // Initialize internal state variables
        this.quit = false;
        this.mem = [];
        this.lastchoice = [];
        
        // Clone data to avoid mutating the original module exports
        // We do a deep copy of keywords because we inject regex objects into them later
        this.keywords = JSON.parse(JSON.stringify(Data.rogerKeywords));
        
        // Lookup tables for pre/post processing
        this.pres = {};
        this.posts = {};
        this.preExp = null;
        this.postExp = null;
        
        // Parse the data and build regexes 
        this._init();
        this.reset();
    }

    /**
     * Resets the bot's state (memory and choice history).
     * 
     */
    reset() {
        this.quit = false;
        this.mem = [];
        this.lastchoice = [];
        
        // Initialize choice counters for every keyword rule to -1
        for (let k = 0; k < this.keywords.length; k++) {
            this.lastchoice[k] = [];
            const rules = this.keywords[k][2];
            for (let i = 0; i < rules.length; i++) {
                this.lastchoice[k][i] = -1;
            }
        }
    }

    /**
     * Parses the raw data into usable Regex objects and lookup tables.
     * Logic derived from to .
     */
    _init() {
        // 1. Create synonym patterns 
        const synPatterns = {};
        if (Data.rogerSynons) {
            for (const i in Data.rogerSynons) {
                // Creates a regex group like (belief|feel|think|believe|wish)
                synPatterns[i] = `(${i}|${Data.rogerSynons[i].join('|')})`;
            }
        }

        // 2. Compile keyword rules into Regexes 
        const sre = /@(\S+)/;                // Matches @synonym
        const are = /(\S)\s*\*\s*(\S)/;      // Matches 'word * word'
        const are1 = /^\s*\*\s*(\S)/;        // Matches '* word' at start
        const are2 = /(\S)\s*\*\s*$/;        // Matches 'word *' at end
        const are3 = /^\s*\*\s*$/;           // Matches just '*'
        const wsre = /\s+/g;                 // Matches whitespace

        for (let k = 0; k < this.keywords.length; k++) {
            const rules = this.keywords[k][2];
            this.keywords[k][3] = k; // Save original index for sorting stability 

            for (let i = 0; i < rules.length; i++) {
                const r = rules[i];
                
                // Check memory flag ('$') at start of rule
                // If rule starts with $, it uses memory (decomp element 2 set to true)
                if (r[0].charAt(0) === '$') {
                    let ofs = 1;
                    while (r[0].charAt(ofs) === ' ') ofs++;
                    r[0] = r[0].substring(ofs);
                    r[2] = true;
                } else {
                    r[2] = false;
                }

                // Expand synonyms (replace @word with regex group)
                let m = sre.exec(r[0]);
                while (m) {
                    const sp = synPatterns[m[1]] ? synPatterns[m[1]] : m[1];
                    r[0] = r[0].substring(0, m.index) + sp + r[0].substring(m.index + m[0].length);
                    m = sre.exec(r[0]);
                }

                // Expand asterisk (*) into capture groups (.*)
                // This logic handles wildcards differently based on position (start, middle, end)
                if (are3.test(r[0])) {
                    r[0] = '\\s*(.*)\\s*';
                } else {
                    m = are.exec(r[0]);
                    if (m) {
                        let lp = '';
                        let rp = r[0];
                        while (m) {
                            lp += rp.substring(0, m.index + 1);
                            if (m[1] !== ')') lp += '\\b';
                            lp += '\\s*(.*)\\s*';
                            if (m[2] !== '(' && m[2] !== '\\') lp += '\\b';
                            lp += m[2];
                            rp = rp.substring(m.index + m[0].length);
                            m = are.exec(rp);
                        }
                        r[0] = lp + rp;
                    }
                    m = are1.exec(r[0]);
                    if (m) {
                        let lp = '\\s*(.*)\\s*';
                        if (m[1] !== ')' && m[1] !== '\\') lp += '\\b';
                        r[0] = lp + r[0].substring(m.index - 1 + m[0].length);
                    }
                    m = are2.exec(r[0]);
                    if (m) {
                        let lp = r[0].substring(0, m.index + 1);
                        if (m[1] !== '(') lp += '\\b';
                        r[0] = lp + '\\s*(.*)\\s*';
                    }
                }

                // Expand whitespace to match multiple spaces
                r[0] = r[0].replace(wsre, '\\s+');
                wsre.lastIndex = 0;
            }
        }

        // 3. Sort keywords by Rank (priority) 
        this.keywords.sort(this._sortKeywords);

        // 4. Compose Regex and Maps for Pre-processing 
        if (Data.rogerPres && Data.rogerPres.length) {
            const a = [];
            for (let i = 0; i < Data.rogerPres.length; i += 2) {
                a.push(Data.rogerPres[i]);
                this.pres[Data.rogerPres[i]] = Data.rogerPres[i + 1];
            }
            this.preExp = new RegExp(`\\b(${a.join('|')})\\b`);
        } else {
            this.preExp = /####/;
            this.pres['####'] = '####';
        }

        // 5. Compose Regex and Maps for Post-processing 
        if (Data.rogerPosts && Data.rogerPosts.length) {
            const a = [];
            for (let i = 0; i < Data.rogerPosts.length; i += 2) {
                a.push(Data.rogerPosts[i]);
                this.posts[Data.rogerPosts[i]] = Data.rogerPosts[i + 1];
            }
            this.postExp = new RegExp(`\\b(${a.join('|')})\\b`);
        } else {
            this.postExp = /####/;
            this.posts['####'] = '####';
        }
    }

    /**
     * Comparator for sorting keywords.
     * Sorts by Rank (descending), then original index (ascending).
     * 
     */
    _sortKeywords(a, b) {
        if (a[1] > b[1]) return -1;
        else if (a[1] < b[1]) return 1;
        else if (a[3] > b[3]) return 1;
        else if (a[3] < b[3]) return -1;
        else return 0;
    }

    /**
     * The main entry point to process user input.
     * @param {string} text - The user's input string.
     * @returns {string} The bot's response.
     * 
     */
    transform(text) {
        let rpl = '';
        this.quit = false;

        // Normalize text
        text = text.toLowerCase();
        // Remove special chars, replace with space
        text = text.replace(/@#\$%\^&\*\(\)_\+=~`\{\[\}\]\|:;<>\/\\\t/g, ' ');
        // Treat dashes and punctuation as sentence terminators
        text = text.replace(/\s+-+\s+/g, '.');
        text = text.replace(/\s*[,\.\?!;]+\s*/g, '.');
        text = text.replace(/\s*\bbut\b\s*/g, '.');
        text = text.replace(/\s{2,}/g, ' ');

        // Split text into sentences and process each
        const parts = text.split('.');
        
        // Loop through parts 
        for (let i = 0; i < parts.length; i++) {
            let part = parts[i];
            if (part !== '') {
                // Check for quit expressions
                if (Data.rogerQuits.includes(part)) {
                    this.quit = true;
                    return this.getFinal();
                }

                // Preprocess: perform substitutions (e.g., "don't" -> "do not")
                // 
                let m = this.preExp.exec(part);
                if (m) {
                    let lp = '';
                    let rp = part;
                    while (m) {
                        lp += rp.substring(0, m.index) + this.pres[m[1]];
                        rp = rp.substring(m.index + m[0].length);
                        m = this.preExp.exec(rp);
                    }
                    part = lp + rp;
                }
                this.sentence = part;

                // Loop through keywords to find a match 
                for (let k = 0; k < this.keywords.length; k++) {
                    // Check if keyword exists in the sentence
                    if (part.search(new RegExp(`\\b${this.keywords[k][0]}\\b`, 'i')) >= 0) {
                        rpl = this._execRule(k);
                    }
                    if (rpl !== '') return rpl;
                }
            }
        }

        // If no direct keyword match, try retrieving from memory 
        rpl = this._memGet();

        // If memory is empty, fallback to 'xnone' (generic fallback)
        if (rpl === '') {
            this.sentence = ' ';
            const k = this._getRuleIndexByKey('xnone');
            if (k >= 0) rpl = this._execRule(k);
        }

        // Return reply or ultimate fallback 
        return (rpl !== '') ? rpl : 'I am at a loss for words.';
    }

    /**
     * Executes the decomposition and reassembly rules for a specific keyword.
     * @param {number} k - Index of the keyword in the sorted array.
     * @returns {string} The constructed response or empty string.
     * 
     */
    _execRule(k) {
        const rule = this.keywords[k];
        const decomps = rule[2];
        const paramre = /\(([0-9]+)\)/; // Matches (1), (2), etc. used for substitutions

        for (let i = 0; i < decomps.length; i++) {
            // Attempt to match the decomposition regex against the sentence
            const m = this.sentence.match(decomps[i][0]);
            
            if (m != null) {
                const reasmbs = decomps[i][1];
                const memflag = decomps[i][2];
                
                // Select a reassembly rule (random or sequential) 
                let ri = (this.noRandom) ? 0 : Math.floor(Math.random() * reasmbs.length);
                
                if (((this.noRandom) && (this.lastchoice[k][i] > ri)) || (this.lastchoice[k][i] === ri)) {
                    ri = ++this.lastchoice[k][i];
                    if (ri >= reasmbs.length) {
                        ri = 0;
                        this.lastchoice[k][i] = -1;
                    }
                } else {
                    this.lastchoice[k][i] = ri;
                }
                
                let rpl = reasmbs[ri];

                if (this.debug) {
                    console.log(`match:\nkey: ${this.keywords[k][0]}\nrank: ${this.keywords[k][1]}\ndecomp: ${decomps[i][0]}\nreasmb: ${rpl}\nmemflag: ${memflag}`);
                }

                // Handle 'goto' logic (redirect to another keyword) 
                if (rpl.search(/^goto /i) === 0) {
                    const ki = this._getRuleIndexByKey(rpl.substring(5));
                    if (ki >= 0) return this._execRule(ki);
                }

                // Substitute positional params (replace (N) with capture group N)
                // 
                let m1 = paramre.exec(rpl);
                if (m1) {
                    let lp = '';
                    let rp = rpl;
                    while (m1) {
                        let param = m[parseInt(m1[1])]; // Get the captured text from the input
                        
                        // Post-process the parameter (conjugate words like "I" <-> "You")
                        // 
                        let m2 = this.postExp.exec(param);
                        if (m2) {
                            let lp2 = '';
                            let rp2 = param;
                            while (m2) {
                                lp2 += rp2.substring(0, m2.index) + this.posts[m2[1]];
                                rp2 = rp2.substring(m2.index + m2[0].length);
                                m2 = this.postExp.exec(rp2);
                            }
                            param = lp2 + rp2;
                        }
                        
                        lp += rp.substring(0, m1.index) + param;
                        rp = rp.substring(m1.index + m1[0].length);
                        m1 = paramre.exec(rp);
                    }
                    rpl = lp + rp;
                }

                rpl = this._postTransform(rpl);

                // If this is a memory rule, save it for later instead of returning immediately
                if (memflag) {
                    this._memSave(rpl);
                } else {
                    return rpl;
                }
            }
        }
        return '';
    }

    /**
     * Final cleanup of the generated response.
     * Handles capitalization and specific regex fixes.
     * 
     */
    _postTransform(s) {
        s = s.replace(/\s{2,}/g, ' ');
        s = s.replace(/\s+\./g, '.');

        // Apply external transform rules (e.g. for "old old" or "they were me") 
        if (Data.rogerPostTransforms && Data.rogerPostTransforms.length) {
            for (let i = 0; i < Data.rogerPostTransforms.length; i += 2) {
                s = s.replace(Data.rogerPostTransforms[i], Data.rogerPostTransforms[i + 1]);
                Data.rogerPostTransforms[i].lastIndex = 0;
            }
        }

        // Capitalize first character 
        if (this.capitalizeFirstLetter) {
            const re = /^([a-z])/;
            const m = re.exec(s);
            if (m) s = m[0].toUpperCase() + s.substring(1);
        }
        return s;
    }

    /**
     * Helper: Find the index of a keyword string in the keyword array.
     * 
     */
    _getRuleIndexByKey(key) {
        for (let k = 0; k < this.keywords.length; k++) {
            if (this.keywords[k][0] === key) return k;
        }
        return -1;
    }

    /**
     * Save a response to memory for later retrieval.
     * 
     */
    _memSave(t) {
        this.mem.push(t);
        if (this.mem.length > this.memSize) this.mem.shift();
    }

    /**
     * Retrieve a response from memory.
     * 
     */
    _memGet() {
        if (this.mem.length) {
            if (this.noRandom) {
                return this.mem.shift();
            } else {
                const n = Math.floor(Math.random() * this.mem.length);
                const rpl = this.mem[n];
                // Remove the used item from memory manually
                for (let i = n + 1; i < this.mem.length; i++) this.mem[i - 1] = this.mem[i];
                this.mem.length--;
                return rpl;
            }
        } else {
            return '';
        }
    }

    /**
     * Returns a random final goodbye message.
     * 
     */
    getFinal() {
        if (!Data.rogerFinals) return '';
        return Data.rogerFinals[Math.floor(Math.random() * Data.rogerFinals.length)];
    }

    /**
     * Returns a random greeting message.
     * 
     */
    getInitial() {
        if (!Data.rogerInitials) return '';
        return Data.rogerInitials[Math.floor(Math.random() * Data.rogerInitials.length)];
    }
}